# 模組3.1：SQL基礎與進階應用

## 學習目標
完成本模組後，學員將能夠：
- 理解AS/400平台上SQL的特性與架構
- 掌握基本的SQL DDL、DML語法
- 熟悉各種查詢技巧與函數應用
- 了解索引設計與效能優化
- 具備複雜查詢與報表設計能力
- 掌握交易控制與並行處理
- 能夠進行資料庫設計與維護

## 課程大綱

### 1. AS/400 SQL 概述

#### 1.1 IBM i SQL特性
IBM i上的SQL具有以下特色：

- **完全整合**：與檔案系統完全整合
- **標準相容**：支援SQL標準語法
- **效能優異**：查詢優化器自動優化
- **安全機制**：完整的權限控制
- **擴充功能**：支援IBM i特有功能

#### 1.2 SQL與傳統檔案存取比較

| 特性 | 傳統RPG檔案存取 | SQL |
|------|----------------|-----|
| 學習曲線 | 較陡峭 | 較平緩 |
| 查詢彈性 | 受限於邏輯檔案 | 極為彈性 |
| 效能表現 | 可預測 | 依查詢複雜度 |
| 維護性 | 需要DDS | 純文字SQL |
| 跨平台性 | AS/400專用 | 標準SQL |

#### 1.3 SQL環境設定
```sql
-- 啟動互動式SQL
STRSQL

-- 設定SQL選項
SET OPTION COMMIT = *NONE;
SET OPTION DATFMT = *ISO;
SET OPTION TIMFMT = *HMS;
SET OPTION DECIMAL = (31, 31);
```

### 2. 基礎SQL語法

#### 2.1 資料定義語言 (DDL)

**建立資料表**
```sql
-- 建立客戶主檔
CREATE TABLE MYLIB/CUSTOMER (
    CUSTNO DECIMAL(6,0) NOT NULL,
    CUSTNAME VARCHAR(30) NOT NULL,
    ADDRESS VARCHAR(40),
    CITY VARCHAR(20),
    STATE CHAR(2),
    ZIPCODE CHAR(10),
    PHONE VARCHAR(15),
    EMAIL VARCHAR(50),
    BALANCE DECIMAL(9,2) DEFAULT 0,
    CREDITLMT DECIMAL(9,2) DEFAULT 0,
    STATUS CHAR(1) DEFAULT 'A',
    CREATEDATE DATE DEFAULT CURRENT_DATE,
    UPDATETIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (CUSTNO)
);

-- 建立訂單檔
CREATE TABLE MYLIB/ORDERS (
    ORDERNO DECIMAL(8,0) NOT NULL,
    CUSTNO DECIMAL(6,0) NOT NULL,
    ORDERDATE DATE DEFAULT CURRENT_DATE,
    SHIPDATE DATE,
    ORDERAMT DECIMAL(9,2) DEFAULT 0,
    STATUS CHAR(1) DEFAULT 'O',
    SALESREP VARCHAR(20),
    NOTES VARCHAR(200),
    PRIMARY KEY (ORDERNO),
    FOREIGN KEY (CUSTNO) REFERENCES MYLIB/CUSTOMER(CUSTNO)
);

-- 建立訂單明細檔
CREATE TABLE MYLIB/ORDERITEMS (
    ORDERNO DECIMAL(8,0) NOT NULL,
    ITEMNO DECIMAL(3,0) NOT NULL,
    PRODCODE VARCHAR(15) NOT NULL,
    PRODNAME VARCHAR(40),
    QUANTITY DECIMAL(5,0) NOT NULL,
    UNITPRICE DECIMAL(7,2) NOT NULL,
    LINEAMT DECIMAL(9,2) NOT NULL,
    PRIMARY KEY (ORDERNO, ITEMNO),
    FOREIGN KEY (ORDERNO) REFERENCES MYLIB/ORDERS(ORDERNO)
);
```

**修改資料表結構**
```sql
-- 新增欄位
ALTER TABLE MYLIB/CUSTOMER 
ADD COLUMN WEBSITE VARCHAR(100);

-- 修改欄位
ALTER TABLE MYLIB/CUSTOMER 
ALTER COLUMN PHONE SET DATA TYPE VARCHAR(20);

-- 刪除欄位
ALTER TABLE MYLIB/CUSTOMER 
DROP COLUMN WEBSITE;

-- 新增約束條件
ALTER TABLE MYLIB/CUSTOMER 
ADD CONSTRAINT CHK_STATUS 
CHECK (STATUS IN ('A', 'I', 'S'));

-- 建立索引
CREATE INDEX MYLIB/IDX_CUST_NAME 
ON MYLIB/CUSTOMER (CUSTNAME);

CREATE UNIQUE INDEX MYLIB/IDX_CUST_EMAIL 
ON MYLIB/CUSTOMER (EMAIL);
```

#### 2.2 資料操作語言 (DML)

**插入資料**
```sql
-- 單筆插入
INSERT INTO MYLIB/CUSTOMER 
(CUSTNO, CUSTNAME, ADDRESS, CITY, STATE, PHONE, BALANCE, CREDITLMT)
VALUES 
(100001, '台灣科技股份有限公司', '台北市信義區信義路100號', '台北市', 'TP', '02-27001234', 50000.00, 100000.00);

-- 多筆插入
INSERT INTO MYLIB/CUSTOMER VALUES
(100002, '高雄工業有限公司', '高雄市前鎮區中山路200號', '高雄市', 'KH', '07-3334567', 30000.00, 80000.00, 'A', CURRENT_DATE, CURRENT_TIMESTAMP),
(100003, '台中貿易商行', '台中市西屯區台灣大道300號', '台中市', 'TC', '04-2223456', 25000.00, 60000.00, 'A', CURRENT_DATE, CURRENT_TIMESTAMP),
(100004, '新竹電子企業', '新竹市東區光復路400號', '新竹市', 'HC', '03-5671234', 75000.00, 150000.00, 'A', CURRENT_DATE, CURRENT_TIMESTAMP);

-- 從其他表插入
INSERT INTO MYLIB/CUSTOMER_BACKUP 
SELECT * FROM MYLIB/CUSTOMER 
WHERE STATUS = 'A';
```

**查詢資料**
```sql
-- 基本查詢
SELECT * FROM MYLIB/CUSTOMER;

-- 指定欄位查詢
SELECT CUSTNO, CUSTNAME, BALANCE 
FROM MYLIB/CUSTOMER;

-- 條件查詢
SELECT CUSTNO, CUSTNAME, BALANCE 
FROM MYLIB/CUSTOMER 
WHERE BALANCE > 50000;

-- 排序查詢
SELECT CUSTNO, CUSTNAME, BALANCE 
FROM MYLIB/CUSTOMER 
ORDER BY BALANCE DESC, CUSTNAME ASC;

-- 限制筆數
SELECT CUSTNO, CUSTNAME, BALANCE 
FROM MYLIB/CUSTOMER 
ORDER BY BALANCE DESC 
FETCH FIRST 10 ROWS ONLY;
```

**更新資料**
```sql
-- 單一條件更新
UPDATE MYLIB/CUSTOMER 
SET BALANCE = BALANCE + 10000 
WHERE CUSTNO = 100001;

-- 多欄位更新
UPDATE MYLIB/CUSTOMER 
SET BALANCE = 0, 
    STATUS = 'I',
    UPDATETIME = CURRENT_TIMESTAMP 
WHERE BALANCE < 0;

-- 子查詢更新
UPDATE MYLIB/CUSTOMER 
SET CREDITLMT = BALANCE * 2 
WHERE CUSTNO IN (
    SELECT CUSTNO FROM MYLIB/ORDERS 
    WHERE ORDERAMT > 50000
);
```

**刪除資料**
```sql
-- 條件刪除
DELETE FROM MYLIB/CUSTOMER 
WHERE STATUS = 'I' AND BALANCE = 0;

-- 子查詢刪除
DELETE FROM MYLIB/CUSTOMER 
WHERE CUSTNO NOT IN (
    SELECT DISTINCT CUSTNO FROM MYLIB/ORDERS
);
```

### 3. 進階查詢技巧

#### 3.1 聯結查詢 (JOIN)

**內部聯結 (INNER JOIN)**
```sql
-- 客戶訂單聯結
SELECT C.CUSTNO, C.CUSTNAME, O.ORDERNO, O.ORDERDATE, O.ORDERAMT
FROM MYLIB/CUSTOMER C
INNER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
WHERE C.STATUS = 'A'
ORDER BY C.CUSTNAME, O.ORDERDATE;

-- 三表聯結
SELECT C.CUSTNAME, O.ORDERNO, OI.PRODNAME, OI.QUANTITY, OI.UNITPRICE
FROM MYLIB/CUSTOMER C
INNER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
INNER JOIN MYLIB/ORDERITEMS OI ON O.ORDERNO = OI.ORDERNO
WHERE O.ORDERDATE >= '2025-01-01'
ORDER BY C.CUSTNAME, O.ORDERNO, OI.ITEMNO;
```

**外部聯結 (OUTER JOIN)**
```sql
-- 左外部聯結 - 顯示所有客戶，包含沒有訂單的客戶
SELECT C.CUSTNO, C.CUSTNAME, O.ORDERNO, O.ORDERAMT
FROM MYLIB/CUSTOMER C
LEFT OUTER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
ORDER BY C.CUSTNAME;

-- 右外部聯結 - 顯示所有訂單，包含可能不存在的客戶
SELECT C.CUSTNAME, O.ORDERNO, O.ORDERDATE, O.ORDERAMT
FROM MYLIB/CUSTOMER C
RIGHT OUTER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
ORDER BY O.ORDERDATE;

-- 完全外部聯結
SELECT C.CUSTNAME, O.ORDERNO, O.ORDERAMT
FROM MYLIB/CUSTOMER C
FULL OUTER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO;
```

#### 3.2 子查詢 (Subquery)

**標量子查詢**
```sql
-- 查詢餘額高於平均值的客戶
SELECT CUSTNO, CUSTNAME, BALANCE
FROM MYLIB/CUSTOMER
WHERE BALANCE > (SELECT AVG(BALANCE) FROM MYLIB/CUSTOMER)
ORDER BY BALANCE DESC;

-- 查詢每個客戶的訂單總額
SELECT C.CUSTNO, C.CUSTNAME,
       (SELECT SUM(ORDERAMT) 
        FROM MYLIB/ORDERS O 
        WHERE O.CUSTNO = C.CUSTNO) AS TOTAL_ORDERS
FROM MYLIB/CUSTOMER C
ORDER BY TOTAL_ORDERS DESC;
```

**表格子查詢**
```sql
-- 查詢有訂單的客戶
SELECT CUSTNO, CUSTNAME, BALANCE
FROM MYLIB/CUSTOMER
WHERE CUSTNO IN (SELECT DISTINCT CUSTNO FROM MYLIB/ORDERS);

-- 查詢沒有訂單的客戶
SELECT CUSTNO, CUSTNAME, BALANCE
FROM MYLIB/CUSTOMER
WHERE CUSTNO NOT IN (
    SELECT CUSTNO FROM MYLIB/ORDERS 
    WHERE CUSTNO IS NOT NULL
);

-- EXISTS子查詢
SELECT C.CUSTNO, C.CUSTNAME
FROM MYLIB/CUSTOMER C
WHERE EXISTS (
    SELECT 1 FROM MYLIB/ORDERS O 
    WHERE O.CUSTNO = C.CUSTNO 
    AND O.ORDERAMT > 10000
);
```

#### 3.3 聚合函數與分組

**基本聚合函數**
```sql
-- 統計函數
SELECT 
    COUNT(*) AS 客戶總數,
    COUNT(EMAIL) AS 有Email客戶數,
    AVG(BALANCE) AS 平均餘額,
    SUM(BALANCE) AS 總餘額,
    MAX(BALANCE) AS 最高餘額,
    MIN(BALANCE) AS 最低餘額,
    MAX(CREATEDATE) AS 最新建立日期
FROM MYLIB/CUSTOMER;
```

**GROUP BY分組查詢**
```sql
-- 按城市分組統計
SELECT CITY, 
       COUNT(*) AS 客戶數量,
       AVG(BALANCE) AS 平均餘額,
       SUM(BALANCE) AS 總餘額
FROM MYLIB/CUSTOMER
WHERE STATUS = 'A'
GROUP BY CITY
ORDER BY 總餘額 DESC;

-- 按狀態和城市分組
SELECT STATUS, CITY,
       COUNT(*) AS 客戶數量,
       AVG(BALANCE) AS 平均餘額
FROM MYLIB/CUSTOMER
GROUP BY STATUS, CITY
ORDER BY STATUS, CITY;
```

**HAVING條件過濾**
```sql
-- 找出客戶數量大於5的城市
SELECT CITY, COUNT(*) AS 客戶數量
FROM MYLIB/CUSTOMER
GROUP BY CITY
HAVING COUNT(*) > 5
ORDER BY 客戶數量 DESC;

-- 找出平均訂單金額超過50000的客戶
SELECT C.CUSTNO, C.CUSTNAME, 
       COUNT(O.ORDERNO) AS 訂單數量,
       AVG(O.ORDERAMT) AS 平均訂單金額
FROM MYLIB/CUSTOMER C
INNER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
GROUP BY C.CUSTNO, C.CUSTNAME
HAVING AVG(O.ORDERAMT) > 50000
ORDER BY 平均訂單金額 DESC;
```

### 4. 高級SQL功能

#### 4.1 視圖 (VIEW)

**建立視圖**
```sql
-- 建立客戶摘要視圖
CREATE VIEW MYLIB/V_CUSTOMER_SUMMARY AS
SELECT C.CUSTNO, C.CUSTNAME, C.CITY, C.BALANCE,
       COUNT(O.ORDERNO) AS 訂單數量,
       COALESCE(SUM(O.ORDERAMT), 0) AS 訂單總額,
       COALESCE(AVG(O.ORDERAMT), 0) AS 平均訂單金額
FROM MYLIB/CUSTOMER C
LEFT JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
WHERE C.STATUS = 'A'
GROUP BY C.CUSTNO, C.CUSTNAME, C.CITY, C.BALANCE;

-- 建立高價值客戶視圖
CREATE VIEW MYLIB/V_VIP_CUSTOMERS AS
SELECT CUSTNO, CUSTNAME, BALANCE, CREDITLMT
FROM MYLIB/CUSTOMER
WHERE BALANCE > 100000 OR CREDITLMT > 200000;
```

**使用視圖**
```sql
-- 查詢視圖
SELECT * FROM MYLIB/V_CUSTOMER_SUMMARY
ORDER BY 訂單總額 DESC;

-- 透過視圖更新資料（如果視圖支援更新）
UPDATE MYLIB/V_VIP_CUSTOMERS 
SET CREDITLMT = CREDITLMT * 1.1 
WHERE BALANCE > 500000;
```

#### 4.2 通用表格式 (CTE)

```sql
-- 遞迴CTE - 組織階層查詢
WITH RECURSIVE EMPLOYEE_HIERARCHY (EMPID, EMPNAME, MGRID, LEVEL, PATH) AS (
    -- 基礎查詢：找出最高層主管
    SELECT EMPID, EMPNAME, MGRID, 1, CAST(EMPNAME AS VARCHAR(1000))
    FROM MYLIB/EMPLOYEE
    WHERE MGRID IS NULL
    
    UNION ALL
    
    -- 遞迴查詢：找出下屬
    SELECT E.EMPID, E.EMPNAME, E.MGRID, EH.LEVEL + 1, 
           EH.PATH || ' -> ' || E.EMPNAME
    FROM MYLIB/EMPLOYEE E
    INNER JOIN EMPLOYEE_HIERARCHY EH ON E.MGRID = EH.EMPID
)
SELECT EMPID, EMPNAME, LEVEL, PATH
FROM EMPLOYEE_HIERARCHY
ORDER BY LEVEL, EMPNAME;

-- 非遞迴CTE - 複雜查詢分解
WITH CUSTOMER_STATS AS (
    SELECT CUSTNO, 
           COUNT(*) AS ORDER_COUNT,
           SUM(ORDERAMT) AS TOTAL_AMOUNT,
           AVG(ORDERAMT) AS AVG_AMOUNT
    FROM MYLIB/ORDERS
    WHERE ORDERDATE >= '2025-01-01'
    GROUP BY CUSTNO
),
HIGH_VALUE_CUSTOMERS AS (
    SELECT CUSTNO FROM CUSTOMER_STATS
    WHERE TOTAL_AMOUNT > 100000
)
SELECT C.CUSTNAME, CS.ORDER_COUNT, CS.TOTAL_AMOUNT, CS.AVG_AMOUNT
FROM MYLIB/CUSTOMER C
INNER JOIN CUSTOMER_STATS CS ON C.CUSTNO = CS.CUSTNO
INNER JOIN HIGH_VALUE_CUSTOMERS HVC ON C.CUSTNO = HVC.CUSTNO
ORDER BY CS.TOTAL_AMOUNT DESC;
```

#### 4.3 窗口函數 (Window Functions)

```sql
-- ROW_NUMBER() 排序編號
SELECT CUSTNO, CUSTNAME, BALANCE,
       ROW_NUMBER() OVER (ORDER BY BALANCE DESC) AS 餘額排名
FROM MYLIB/CUSTOMER
WHERE STATUS = 'A';

-- RANK() 和 DENSE_RANK() 排名
SELECT CUSTNO, CUSTNAME, BALANCE,
       RANK() OVER (ORDER BY BALANCE DESC) AS 排名,
       DENSE_RANK() OVER (ORDER BY BALANCE DESC) AS 密集排名
FROM MYLIB/CUSTOMER
WHERE STATUS = 'A';

-- 分區排名
SELECT CUSTNO, CUSTNAME, CITY, BALANCE,
       RANK() OVER (PARTITION BY CITY ORDER BY BALANCE DESC) AS 城市內排名
FROM MYLIB/CUSTOMER
WHERE STATUS = 'A'
ORDER BY CITY, 城市內排名;

-- 移動平均和累計
SELECT CUSTNO, CUSTNAME, BALANCE,
       AVG(BALANCE) OVER (ORDER BY CUSTNO ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS 移動平均,
       SUM(BALANCE) OVER (ORDER BY CUSTNO ROWS UNBOUNDED PRECEDING) AS 累計餘額
FROM MYLIB/CUSTOMER
WHERE STATUS = 'A'
ORDER BY CUSTNO;

-- LAG() 和 LEAD() 前後值比較
SELECT O.CUSTNO, O.ORDERDATE, O.ORDERAMT,
       LAG(ORDERAMT, 1) OVER (PARTITION BY CUSTNO ORDER BY ORDERDATE) AS 前一筆訂單金額,
       LEAD(ORDERAMT, 1) OVER (PARTITION BY CUSTNO ORDER BY ORDERDATE) AS 下一筆訂單金額,
       ORDERAMT - LAG(ORDERAMT, 1) OVER (PARTITION BY CUSTNO ORDER BY ORDERDATE) AS 金額變化
FROM MYLIB/ORDERS O
ORDER BY O.CUSTNO, O.ORDERDATE;
```

### 5. 內建函數應用

#### 5.1 字串函數

```sql
-- 字串處理函數
SELECT CUSTNO, CUSTNAME,
       LENGTH(CUSTNAME) AS 名稱長度,
       UPPER(CUSTNAME) AS 大寫名稱,
       LOWER(CUSTNAME) AS 小寫名稱,
       SUBSTR(CUSTNAME, 1, 10) AS 名稱前10字,
       TRIM(CUSTNAME) AS 去空白名稱,
       REPLACE(PHONE, '-', '') AS 去除連字號電話,
       CONCAT(CUSTNAME, ' (', CITY, ')') AS 客戶城市
FROM MYLIB/CUSTOMER;

-- 字串搜尋和匹配
SELECT CUSTNO, CUSTNAME, EMAIL
FROM MYLIB/CUSTOMER
WHERE CUSTNAME LIKE '%科技%'
   OR EMAIL LIKE '%@gmail.com'
   OR LOCATE('工業', CUSTNAME) > 0;
```

#### 5.2 日期時間函數

```sql
-- 日期時間函數
SELECT CUSTNO, CUSTNAME, CREATEDATE,
       CURRENT_DATE AS 今天,
       CURRENT_TIME AS 現在時間,
       CURRENT_TIMESTAMP AS 現在時間戳,
       YEAR(CREATEDATE) AS 建立年份,
       MONTH(CREATEDATE) AS 建立月份,
       DAY(CREATEDATE) AS 建立日期,
       DAYOFWEEK(CREATEDATE) AS 星期幾,
       DAYNAME(CREATEDATE) AS 星期名稱,
       MONTHNAME(CREATEDATE) AS 月份名稱,
       DAYS(CURRENT_DATE) - DAYS(CREATEDATE) AS 建立天數,
       CREATEDATE + 30 DAYS AS 建立後30天,
       DATE(UPDATETIME) AS 更新日期,
       TIME(UPDATETIME) AS 更新時間
FROM MYLIB/CUSTOMER;

-- 日期範圍查詢
SELECT COUNT(*) AS 本月新客戶數
FROM MYLIB/CUSTOMER
WHERE CREATEDATE >= DATE(CURRENT_DATE - DAY(CURRENT_DATE) + 1 DAY)
  AND CREATEDATE < DATE(CURRENT_DATE - DAY(CURRENT_DATE) + 1 DAY) + 1 MONTH;
```

#### 5.3 數學函數

```sql
-- 數學計算函數
SELECT CUSTNO, CUSTNAME, BALANCE, CREDITLMT,
       ABS(BALANCE) AS 餘額絕對值,
       ROUND(BALANCE, 0) AS 餘額四捨五入,
       CEILING(BALANCE/1000) AS 餘額千位數向上取整,
       FLOOR(BALANCE/1000) AS 餘額千位數向下取整,
       MOD(CUSTNO, 10) AS 客戶編號餘數,
       POWER(BALANCE/10000, 2) AS 餘額萬元平方,
       SQRT(BALANCE) AS 餘額平方根,
       CASE 
           WHEN BALANCE > CREDITLMT THEN '超限'
           WHEN BALANCE > CREDITLMT * 0.8 THEN '接近超限'
           ELSE '正常'
       END AS 信用狀況
FROM MYLIB/CUSTOMER;
```

#### 5.4 條件函數

```sql
-- 條件判斷函數
SELECT CUSTNO, CUSTNAME, BALANCE, STATUS,
       CASE STATUS
           WHEN 'A' THEN '正常'
           WHEN 'I' THEN '停用'
           WHEN 'S' THEN '暫停'
           ELSE '未知'
       END AS 狀態說明,
       
       CASE 
           WHEN BALANCE >= 100000 THEN 'VIP'
           WHEN BALANCE >= 50000 THEN '金卡'
           WHEN BALANCE >= 10000 THEN '銀卡'
           ELSE '一般'
       END AS 客戶等級,
       
       COALESCE(EMAIL, '無Email') AS Email狀況,
       NULLIF(BALANCE, 0) AS 非零餘額,
       
       GREATEST(BALANCE, CREDITLMT) AS 較大值,
       LEAST(BALANCE, CREDITLMT) AS 較小值
       
FROM MYLIB/CUSTOMER;
```

### 6. 效能優化

#### 6.1 索引設計

```sql
-- 建立各種類型的索引
CREATE INDEX MYLIB/IDX_CUST_BALANCE 
ON MYLIB/CUSTOMER (BALANCE DESC);

CREATE INDEX MYLIB/IDX_CUST_CITY_STATUS 
ON MYLIB/CUSTOMER (CITY, STATUS);

CREATE INDEX MYLIB/IDX_ORDER_DATE_AMT 
ON MYLIB/ORDERS (ORDERDATE, ORDERAMT);

-- 複合索引用於多欄位查詢
CREATE INDEX MYLIB/IDX_ORDER_COMPLEX 
ON MYLIB/ORDERS (CUSTNO, ORDERDATE DESC, STATUS);

-- 部分索引 - 只對特定條件建立索引
CREATE INDEX MYLIB/IDX_ACTIVE_CUSTOMERS 
ON MYLIB/CUSTOMER (CUSTNAME) 
WHERE STATUS = 'A';

-- 查詢索引使用情況
SELECT * FROM QSYS2.SYSINDEXES 
WHERE TABLE_SCHEMA = 'MYLIB' 
AND TABLE_NAME = 'CUSTOMER';
```

#### 6.2 查詢優化技巧

```sql
-- 使用EXPLAIN分析查詢執行計畫
EXPLAIN (FORMAT JSON) 
SELECT C.CUSTNAME, SUM(O.ORDERAMT) AS TOTAL
FROM MYLIB/CUSTOMER C
INNER JOIN MYLIB/ORDERS O ON C.CUSTNO = O.CUSTNO
WHERE C.STATUS = 'A'
GROUP BY C.CUSTNO, C.CUSTNAME
HAVING SUM(O.ORDERAMT) > 50000
ORDER BY TOTAL DESC;

-- 優化前的查詢
SELECT * FROM MYLIB/CUSTOMER
WHERE SUBSTR(CUSTNAME, 1, 3) = '台灣';

-- 優化後的查詢
SELECT * FROM MYLIB/CUSTOMER
WHERE CUSTNAME LIKE '台灣%';

-- 避免在WHERE子句中使用函數
-- 不建議
SELECT * FROM MYLIB/ORDERS
WHERE YEAR(ORDERDATE) = 2025;

-- 建議
SELECT * FROM MYLIB/ORDERS
WHERE ORDERDATE >= '2025-01-01' 
  AND ORDERDATE < '2026-01-01';
```

#### 6.3 統計資訊更新

```sql
-- 更新表格統計資訊
CALL QSYS2.UPDATE_TABLE_STATISTICS('MYLIB', 'CUSTOMER');
CALL QSYS2.UPDATE_TABLE_STATISTICS('MYLIB', 'ORDERS');

-- 查詢統計資訊
SELECT * FROM QSYS2.SYSTABLESTAT 
WHERE TABLE_SCHEMA = 'MYLIB';

-- 查詢欄位統計資訊
SELECT * FROM QSYS2.SYSCOLUMNSTAT 
WHERE TABLE_SCHEMA = 'MYLIB' 
AND TABLE_NAME = 'CUSTOMER';
```

### 7. 交易控制

#### 7.1 交易基本控制

```sql
-- 設定交易隔離層級
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 開始交易（隱含）
START TRANSACTION;

-- 或者設定COMMIT控制
SET OPTION COMMIT = *CHG;

-- 執行多個相關操作
INSERT INTO MYLIB/ORDERS 
VALUES (900001, 100001, CURRENT_DATE, NULL, 15000, 'O', 'SALES01', '新訂單');

INSERT INTO MYLIB/ORDERITEMS VALUES
(900001, 1, 'PROD001', '產品A', 2, 2500.00, 5000.00),
(900001, 2, 'PROD002', '產品B', 1, 10000.00, 10000.00);

UPDATE MYLIB/CUSTOMER 
SET BALANCE = BALANCE - 15000 
WHERE CUSTNO = 100001;

-- 提交交易
COMMIT;

-- 或者回滾交易
ROLLBACK;
```

#### 7.2 儲存點 (SAVEPOINT)

```sql
START TRANSACTION;

-- 建立儲存點
SAVEPOINT SP1;

UPDATE MYLIB/CUSTOMER 
SET BALANCE = BALANCE + 10000 
WHERE CUSTNO = 100001;

-- 建立另一個儲存點
SAVEPOINT SP2;

UPDATE MYLIB/CUSTOMER 
SET CREDITLMT = CREDITLMT + 20000 
WHERE CUSTNO = 100001;

-- 回滾到SP2
ROLLBACK TO SAVEPOINT SP2;

-- 或回滾到SP1
ROLLBACK TO SAVEPOINT SP1;

-- 最終提交
COMMIT;
```

### 8. 實作練習

#### 練習1：建立完整的商業資料庫

```sql
-- 建立產品分類表
CREATE TABLE MYLIB/CATEGORIES (
    CATID DECIMAL(3,0) NOT NULL,
    CATNAME VARCHAR(30) NOT NULL,
    DESCRIPTION VARCHAR(100),
    PRIMARY KEY (CATID)
);

-- 建立產品表
CREATE TABLE MYLIB/PRODUCTS (
    PRODID VARCHAR(15) NOT NULL,
    PRODNAME VARCHAR(40) NOT NULL,
    CATID DECIMAL(3,0),
    UNITPRICE DECIMAL(7,2) DEFAULT 0,
    STOCKQTY DECIMAL(5,0) DEFAULT 0,
    REORDERPOINT DECIMAL(5,0) DEFAULT 0,
    STATUS CHAR(1) DEFAULT 'A',
    CREATEDATE DATE DEFAULT CURRENT_DATE,
    PRIMARY KEY (PRODID),
    FOREIGN KEY (CATID) REFERENCES MYLIB/CATEGORIES(CATID)
);

-- 建立供應商表
CREATE TABLE MYLIB/SUPPLIERS (
    SUPPID DECIMAL(4,0) NOT NULL,
    SUPPNAME VARCHAR(40) NOT NULL,
    CONTACT VARCHAR(30),
    PHONE VARCHAR(15),
    EMAIL VARCHAR(50),
    ADDRESS VARCHAR(100),
    STATUS CHAR(1) DEFAULT 'A',
    PRIMARY KEY (SUPPID)
);

-- 建立產品供應商關聯表
CREATE TABLE MYLIB/PRODUCT_SUPPLIERS (
    PRODID VARCHAR(15) NOT NULL,
    SUPPID DECIMAL(4,0) NOT NULL,
    SUPPLYPRICE DECIMAL(7,2),
    LEADTIME DECIMAL(3,0),
    PRIMARY KEY (PRODID, SUPPID),
    FOREIGN KEY (PRODID) REFERENCES MYLIB/PRODUCTS(PRODID),
    FOREIGN KEY (SUPPID) REFERENCES MYLIB/SUPPLIERS(SUPPID)
);

-- 插入測試資料
INSERT INTO MYLIB/CATEGORIES VALUES
(1, '電子產品', '各種電子設備'),
(2, '辦公用品', '辦公室相關用品'),
(3, '家具用品', '各類家具');

INSERT INTO MYLIB/PRODUCTS VALUES
('ELEC001', '筆記型電腦', 1, 25000.00, 50, 10, 'A', CURRENT_DATE),
('ELEC002', '智慧型手機', 1, 15000.00, 30, 5, 'A', CURRENT_DATE),
('OFFC001', '辦公桌', 3, 8000.00, 20, 3, 'A', CURRENT_DATE),
('OFFC002', '辦公椅', 3, 3000.00, 25, 5, 'A', CURRENT_DATE);
```

#### 練習2：複雜報表查詢

```sql
-- 客戶訂單分析報表
WITH MONTHLY_ORDERS AS (
    SELECT CUSTNO,
           YEAR(ORDERDATE) AS ORDER_YEAR,
           MONTH(ORDERDATE) AS ORDER_MONTH,
           COUNT(*) AS ORDER_COUNT,
           SUM(ORDERAMT) AS MONTHLY_TOTAL
    FROM MYLIB/ORDERS
    WHERE ORDERDATE >= CURRENT_DATE - 12 MONTHS
    GROUP BY CUSTNO, YEAR(ORDERDATE), MONTH(ORDERDATE)
),
CUSTOMER_SUMMARY AS (
    SELECT MO.CUSTNO,
           AVG(MO.MONTHLY_TOTAL) AS AVG_MONTHLY_SALES,
           MAX(MO.MONTHLY_TOTAL) AS MAX_MONTHLY_SALES,
           MIN(MO.MONTHLY_TOTAL) AS MIN_MONTHLY_SALES,
           COUNT(*) AS ACTIVE_MONTHS
    FROM MONTHLY_ORDERS MO
    GROUP BY MO.CUSTNO
)
SELECT C.CUSTNO, C.CUSTNAME, C.CITY,
       CS.AVG_MONTHLY_SALES,
       CS.MAX_MONTHLY_SALES,
       CS.MIN_MONTHLY_SALES,
       CS.ACTIVE_MONTHS,
       CASE 
           WHEN CS.AVG_MONTHLY_SALES > 100000 THEN 'A級客戶'
           WHEN CS.AVG_MONTHLY_SALES > 50000 THEN 'B級客戶'
           WHEN CS.AVG_MONTHLY_SALES > 20000 THEN 'C級客戶'
           ELSE 'D級客戶'
       END AS CUSTOMER_GRADE
FROM MYLIB/CUSTOMER C
INNER JOIN CUSTOMER_SUMMARY CS ON C.CUSTNO = CS.CUSTNO
ORDER BY CS.AVG_MONTHLY_SALES DESC;
```

#### 練習3：庫存管理查詢

```sql
-- 庫存狀況分析
SELECT P.PRODID, P.PRODNAME, C.CATNAME,
       P.STOCKQTY AS 現有庫存,
       P.REORDERPOINT AS 安全庫存,
       CASE 
           WHEN P.STOCKQTY <= 0 THEN '缺貨'
           WHEN P.STOCKQTY <= P.REORDERPOINT THEN '需要補貨'
           WHEN P.STOCKQTY <= P.REORDERPOINT * 2 THEN '庫存偏低'
           ELSE '庫存充足'
       END AS 庫存狀況,
       
       -- 計算30天內的銷售量
       COALESCE((SELECT SUM(OI.QUANTITY)
                FROM MYLIB/ORDERITEMS OI
                INNER JOIN MYLIB/ORDERS O ON OI.ORDERNO = O.ORDERNO
                WHERE OI.PRODCODE = P.PRODID
                  AND O.ORDERDATE >= CURRENT_DATE - 30 DAYS), 0) AS 近30天銷量,
                  
       -- 預估可銷售天數
       CASE 
           WHEN (SELECT SUM(OI.QUANTITY)
                FROM MYLIB/ORDERITEMS OI
                INNER JOIN MYLIB/ORDERS O ON OI.ORDERNO = O.ORDERNO
                WHERE OI.PRODCODE = P.PRODID
                  AND O.ORDERDATE >= CURRENT_DATE - 30 DAYS) > 0
           THEN P.STOCKQTY / ((SELECT SUM(OI.QUANTITY)
                               FROM MYLIB/ORDERITEMS OI
                               INNER JOIN MYLIB/ORDERS O ON OI.ORDERNO = O.ORDERNO
                               WHERE OI.PRODCODE = P.PRODID
                                 AND O.ORDERDATE >= CURRENT_DATE - 30 DAYS) / 30.0)
           ELSE 999
       END AS 預估可銷售天數

FROM MYLIB/PRODUCTS P
INNER JOIN MYLIB/CATEGORIES C ON P.CATID = C.CATID
WHERE P.STATUS = 'A'
ORDER BY 庫存狀況, P.STOCKQTY;
```

### 9. 自我檢測

#### 檢測題目1：SQL基礎（選擇題）
1. 下列哪個SQL語句用於建立資料表？
   - A) INSERT TABLE
   - B) CREATE TABLE
   - C) MAKE TABLE
   - D) BUILD TABLE

2. 在SQL中，哪個子句用於條件篩選？
   - A) ORDER BY
   - B) GROUP BY
   - C) WHERE
   - D) HAVING

3. LEFT OUTER JOIN的特點是？
   - A) 只顯示左表的資料
   - B) 顯示左表所有資料，右表匹配的資料
   - C) 只顯示兩表都有的資料
   - D) 顯示兩表所有資料

#### 檢測題目2：查詢分析
分析下列SQL查詢的功能：
```sql
SELECT C.CUSTNAME, COUNT(O.ORDERNO) AS ORDER_COUNT
FROM CUSTOMER C
LEFT JOIN ORDERS O ON C.CUSTNO = O.CUSTNO
WHERE C.STATUS = 'A'
GROUP BY C.CUSTNO, C.CUSTNAME
HAVING COUNT(O.ORDERNO) >= 5
ORDER BY ORDER_COUNT DESC;
```

#### 檢測題目3：實作練習
請撰寫SQL查詢，完成以下需求：
1. 查詢每個客戶的基本資訊及其最後一筆訂單的日期和金額
2. 找出連續3個月都有下訂單的客戶
3. 計算每個產品類別的平均單價和總庫存價值
4. 找出銷售金額排名前10%的業務員

#### 檢測題目4：效能優化
針對以下查詢，請提出效能優化建議：
```sql
SELECT * FROM CUSTOMER C
WHERE EXISTS (
    SELECT 1 FROM ORDERS O 
    WHERE O.CUSTNO = C.CUSTNO 
    AND YEAR(O.ORDERDATE) = 2025
    AND O.ORDERAMT > 10000
);
```

### 10. 進階應用預覽

#### 10.1 JSON處理
```sql
-- JSON資料處理（DB2 for i 7.3+）
CREATE TABLE MYLIB/CUSTOMER_JSON (
    CUSTNO DECIMAL(6,0) NOT NULL,
    CUSTOMER_DATA JSON,
    PRIMARY KEY (CUSTNO)
);

-- 插入JSON資料
INSERT INTO MYLIB/CUSTOMER_JSON VALUES
(100001, JSON_OBJECT(
    'name': '台灣科技公司',
    'contacts': JSON_ARRAY(
        JSON_OBJECT('type': 'phone', 'value': '02-27001234'),
        JSON_OBJECT('type': 'email', 'value': 'info@taiwan-tech.com')
    )
));

-- 查詢JSON資料
SELECT CUSTNO,
       JSON_VALUE(CUSTOMER_DATA, '$.name') AS CUSTOMER_NAME,
       JSON_VALUE(CUSTOMER_DATA, '$.contacts[0].value') AS PHONE
FROM MYLIB/CUSTOMER_JSON;
```

#### 10.2 資料分析函數
```sql
-- 進階分析函數
SELECT CUSTNO, CUSTNAME, BALANCE,
       NTILE(4) OVER (ORDER BY BALANCE) AS QUARTILE,
       PERCENT_RANK() OVER (ORDER BY BALANCE) AS PERCENTILE,
       CUME_DIST() OVER (ORDER BY BALANCE) AS CUMULATIVE_DIST
FROM MYLIB/CUSTOMER
WHERE STATUS = 'A';
```

### 11. 學習重點總結

✅ **SQL基礎語法**
- DDL：CREATE, ALTER, DROP
- DML：SELECT, INSERT, UPDATE, DELETE
- 查詢條件與排序
- 聚合函數與分組

✅ **進階查詢技巧**
- 各種類型的JOIN
- 子查詢應用
- 視圖建立與使用
- 窗口函數運用

✅ **內建函數應用**
- 字串處理函數
- 日期時間函數
- 數學計算函數
- 條件判斷函數

✅ **效能優化**
- 索引設計原則
- 查詢優化技巧
- 執行計畫分析
- 統計資訊維護

✅ **交易控制**
- 交易隔離層級
- COMMIT和ROLLBACK
- 儲存點使用
- 並行控制

---

**學習建議：**
- 多練習各種查詢組合
- 理解查詢執行計畫
- 關注查詢效能表現
- 培養資料分析思維

**常見錯誤提醒：**
- 忘記GROUP BY包含所有非聚合欄位
- JOIN條件不正確導致笛卡爾積
- 沒有適當的WHERE條件過濾
- 忽略NULL值的處理

**實務應用重點：**
- 複雜報表查詢設計
- 資料清理和轉換
- 效能監控和調優
- 資料安全和權限控制

**預估學習時間：** 24-30小時
**完成標準：** 能夠熟練撰寫各種複雜SQL查詢，理解查詢優化原理，完成所有檢測題目和實作練習
