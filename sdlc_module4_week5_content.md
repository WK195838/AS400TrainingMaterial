# 第四模組：系統設計與架構 (第5週)

**學習時間**：第5週 (6-8小時)  
**先修要求**：完成第三模組 - 需求分析與規格撰寫  
**本週重點**：系統架構設計與詳細設計規劃

---

## 📋 學習目標

完成本週學習後，您將能夠：

✅ **理解系統設計的核心原則與方法論**  
✅ **掌握系統架構模式與設計決策**  
✅ **繪製專業的UML設計圖表**  
✅ **設計有效的資料庫結構**  
✅ **應用UI/UX設計原則創造良好使用者體驗**  
✅ **撰寫完整的系統設計文件**

---

## 🎯 本週學習路徑

```
系統設計基礎 → 架構設計原則 → UML詳細設計 → 資料庫設計 → UI/UX設計 → 設計文件化
      ↓             ↓            ↓           ↓          ↓           ↓
   概念建立       架構思維      設計建模     資料建模    介面設計     文件規範
```

---

## 🏗️ 第一部分：系統設計基礎

### 1.1 系統設計概述

#### 📐 系統設計的定義

**系統設計 (System Design)** 是將需求轉換為系統實作藍圖的過程，包括系統架構、模組結構、介面、資料等各個層面的設計決策。

#### 🎯 設計的目標

**主要目標**：
- **滿足功能需求**：實現所有指定的系統功能
- **達成品質屬性**：滿足非功能性需求（效能、安全性、可用性等）
- **控制複雜度**：將複雜問題分解為可管理的部分
- **促進重用**：設計可重用的組件和模式
- **支援變更**：建立可維護和可擴展的架構

#### 📊 設計層次架構

```
系統層次設計 (System-Level Design)
    ↓
高層設計 (High-Level Design)
    ↓
詳細設計 (Detailed Design)
    ↓
實作 (Implementation)
```

**各層次說明**：

**系統層次設計**：
- 系統分解與邊界定義
- 主要子系統識別
- 系統間介面定義

**高層設計**：
- 架構模式選擇
- 主要組件設計
- 技術平台決策

**詳細設計**：
- 類別和物件設計
- 演算法設計
- 資料結構設計

### 1.2 設計原則

#### 🔧 SOLID原則

**S - 單一責任原則 (Single Responsibility Principle)**
- 一個類別應該只有一個變更的理由
- 每個模組只負責一個功能領域

*範例*：
```
❌ 錯誤設計：
class UserManager {
    validateUser()
    saveUser()
    sendEmail()
    generateReport()
}

✅ 正確設計：
class UserValidator {
    validateUser()
}
class UserRepository {
    saveUser()
}
class EmailService {
    sendEmail()
}
class ReportGenerator {
    generateReport()
}
```

**O - 開放封閉原則 (Open-Closed Principle)**
- 對擴展開放，對修改封閉
- 透過抽象和多態實現擴展性

**L - 里氏替換原則 (Liskov Substitution Principle)**
- 子類別應該能夠替換其父類別
- 保持繼承關係的語意一致性

**I - 介面隔離原則 (Interface Segregation Principle)**
- 客戶端不應該依賴它不需要的介面
- 設計小而專精的介面

**D - 依賴反轉原則 (Dependency Inversion Principle)**
- 高層模組不應該依賴低層模組
- 兩者都應該依賴抽象

#### 🎯 其他重要設計原則

**高內聚，低耦合 (High Cohesion, Low Coupling)**
- **高內聚**：模組內部元素緊密協作
- **低耦合**：模組間依賴關係最小化

**關注點分離 (Separation of Concerns)**
- 將不同關注點分配到不同模組
- 避免功能混雜在一起

**DRY原則 (Don't Repeat Yourself)**
- 避免重複的程式碼和邏輯
- 提取共同功能為可重用組件

**YAGNI原則 (You Aren't Gonna Need It)**
- 不要過度設計未來可能的需求
- 專注於當前確定的需求

### 1.3 系統分解策略

#### 🧩 功能分解

**按功能領域分解**：
```
電商系統
├── 使用者管理
│   ├── 註冊登入
│   ├── 個人資料
│   └── 權限管理
├── 商品管理
│   ├── 商品資訊
│   ├── 庫存管理
│   └── 分類管理
├── 訂單管理
│   ├── 購物車
│   ├── 結帳流程
│   └── 訂單追蹤
└── 支付管理
    ├── 支付處理
    ├── 退款處理
    └── 帳單管理
```

#### 🏛️ 架構分解

**分層架構分解**：
```
展示層 (Presentation Layer)
    ↓
業務邏輯層 (Business Logic Layer)
    ↓
資料存取層 (Data Access Layer)
    ↓
資料層 (Data Layer)
```

**組件架構分解**：
```
前端組件 ←→ API Gateway ←→ 微服務群
    ↓              ↓           ↓
  Web UI      路由與認證    獨立服務
 Mobile UI     負載平衡     資料庫
```

---

## 🏛️ 第二部分：系統架構設計

### 2.1 架構模式概覽

#### 📚 常見架構模式

**1. 分層架構 (Layered Architecture)**

**特點**：
- 系統分為多個水平層次
- 上層只能調用下層的服務
- 每層有明確的責任分工

**優點**：
- 結構清晰，易於理解
- 層次間耦合度低
- 便於開發和維護

**缺點**：
- 效能可能受層次數影響
- 跨層通訊較複雜

**應用場景**：
- 企業應用系統
- Web應用程式
- 傳統資訊系統

**2. 客戶端-伺服器架構 (Client-Server Architecture)**

**結構**：
```
客戶端 ←→ 網路 ←→ 伺服器
   ↓               ↓
使用者介面      業務邏輯
本地處理        資料管理
```

**變體**：
- **胖客戶端**：大部分邏輯在客戶端
- **瘦客戶端**：主要邏輯在伺服器端
- **混合模式**：邏輯分布在兩端

**3. 微服務架構 (Microservices Architecture)**

**核心概念**：
- 應用程式分解為小型獨立服務
- 每個服務負責特定業務功能
- 透過API進行服務間通訊

**優點**：
- 獨立部署和擴展
- 技術棧多樣性
- 故障隔離

**挑戰**：
- 服務間通訊複雜
- 資料一致性問題
- 運維複雜度增加

**4. 事件驅動架構 (Event-Driven Architecture)**

**核心機制**：
```
事件產生者 → 事件匯流排 → 事件消費者
     ↓            ↓           ↓
  發布事件      路由分發     處理事件
```

**應用場景**：
- 即時系統
- 大數據處理
- IoT應用

### 2.2 架構設計決策

#### 🤔 架構決策框架

**決策考量因素**：

**功能需求**：
- 系統必須提供的功能
- 功能間的相依關係
- 整合需求

**品質屬性**：
- 效能要求
- 可擴展性需求
- 安全性要求
- 可用性需求

**約束條件**：
- 技術約束
- 預算限制
- 時程壓力
- 團隊技能

#### 📊 架構權衡分析

**範例：選擇單體 vs 微服務架構**

| 考量因素 | 單體架構 | 微服務架構 |
|----------|----------|------------|
| **開發複雜度** | 低 | 高 |
| **部署複雜度** | 低 | 高 |
| **效能** | 高（本地調用） | 中（網路調用） |
| **可擴展性** | 低 | 高 |
| **技術多樣性** | 低 | 高 |
| **團隊規模要求** | 小團隊適合 | 大團隊適合 |
| **運維成本** | 低 | 高 |

#### 📋 架構決策記錄 (ADR)

**ADR模板**：
```
# ADR-001: 選擇微服務架構

## 狀態
已接受

## 背景
系統需要支援快速擴展，不同模組由不同團隊開發

## 決策
採用微服務架構，使用Docker容器化部署

## 後果
優點：
- 獨立部署和擴展
- 團隊自主性提高
- 技術選擇靈活

缺點：
- 系統複雜度增加
- 需要額外的DevOps投資
- 資料一致性挑戰
```

### 2.3 技術架構設計

#### 🔧 技術棧選擇

**前端技術棧範例**：
```
使用者介面層
├── React.js (UI框架)
├── Redux (狀態管理)
├── Material-UI (元件庫)
└── Webpack (建置工具)

API通訊層
├── Axios (HTTP客戶端)
├── GraphQL (查詢語言)
└── Socket.io (即時通訊)
```

**後端技術棧範例**：
```
應用服務層
├── Node.js (執行環境)
├── Express.js (Web框架)
├── TypeScript (程式語言)
└── JWT (認證機制)

資料存取層
├── MongoDB (文件資料庫)
├── Redis (快取資料庫)
├── Mongoose (ODM)
└── Bull (佇列處理)
```

#### 🌐 系統整合設計

**API設計原則**：
- **RESTful設計**：遵循REST原則
- **版本控制**：支援API版本演進
- **錯誤處理**：統一的錯誤回應格式
- **文件化**：完整的API文件

**安全性設計**：
- **認證授權**：OAuth 2.0、JWT
- **資料加密**：HTTPS、資料庫加密
- **輸入驗證**：防止SQL注入、XSS攻擊
- **日誌監控**：安全事件記錄

---

## 📊 第三部分：UML詳細設計

### 3.1 UML概述

#### 🎨 UML圖表分類

**結構圖 (Structure Diagrams)**：
- 類別圖 (Class Diagram)
- 物件圖 (Object Diagram)
- 組件圖 (Component Diagram)
- 部署圖 (Deployment Diagram)

**行為圖 (Behavior Diagrams)**：
- 使用案例圖 (Use Case Diagram)
- 序列圖 (Sequence Diagram)
- 活動圖 (Activity Diagram)
- 狀態機圖 (State Machine Diagram)

### 3.2 類別圖設計

#### 📋 類別圖基本元素

**類別表示法**：
```
┌─────────────────┐
│   類別名稱      │
├─────────────────┤
│ - 私有屬性      │
│ + 公開屬性      │
│ # 保護屬性      │
├─────────────────┤
│ + 公開方法()    │
│ - 私有方法()    │
│ # 保護方法()    │
└─────────────────┘
```

**關係類型**：
- **關聯 (Association)**：`────>`
- **聚合 (Aggregation)**：`◇────>`
- **組合 (Composition)**：`◆────>`
- **繼承 (Inheritance)**：`────△`
- **實作 (Realization)**：`┈┈┈△`
- **依賴 (Dependency)**：`┈┈┈>`

#### 🛒 電商系統類別圖範例

```
┌─────────────────┐      ┌─────────────────┐
│     User        │      │    Product      │
├─────────────────┤      ├─────────────────┤
│ - userId: int   │      │ - productId: int│
│ - email: String │      │ - name: String  │
│ - password: Str │ 1──* │ - price: double │
│ - name: String  │      │ - stock: int    │
├─────────────────┤      ├─────────────────┤
│ + login()       │      │ + updateStock() │
│ + register()    │      │ + getPrice()    │
│ + updateProfile()│     │ + isAvailable() │
└─────────────────┘      └─────────────────┘
         │                        │
         │ 1                      │ *
         │                        │
         ▼                        ▼
┌─────────────────┐      ┌─────────────────┐
│  ShoppingCart   │ *──* │   CartItem      │
├─────────────────┤      ├─────────────────┤
│ - cartId: int   │      │ - quantity: int │
│ - userId: int   │      │ - addedDate: Date│
├─────────────────┤      ├─────────────────┤
│ + addItem()     │      │ + updateQty()   │
│ + removeItem()  │      │ + getSubtotal() │
│ + getTotalPrice()│     │ + remove()      │
└─────────────────┘      └─────────────────┘
```

#### 🎯 類別設計最佳實務

**命名慣例**：
- 類別名稱：PascalCase (UserAccount)
- 屬性名稱：camelCase (firstName)
- 方法名稱：camelCase (calculateTotal)
- 常數：UPPER_SNAKE_CASE (MAX_RETRY_COUNT)

**設計原則應用**：
- **封裝**：隱藏內部實作細節
- **繼承**：建立is-a關係
- **多型**：支援介面一致性
- **抽象**：定義共同介面

### 3.3 序列圖設計

#### 📈 序列圖元素

**基本元素**：
- **物件 (Object)**：參與互動的實體
- **生命線 (Lifeline)**：物件存在的時間
- **訊息 (Message)**：物件間的通訊
- **啟動框 (Activation Box)**：物件活躍時間

#### 💳 線上購物結帳序列圖

```
客戶    購物車    訂單服務   支付服務   庫存服務   Email服務
 │        │         │         │         │         │
 │─結帳──→│         │         │         │         │
 │        │─建立訂單→│         │         │         │
 │        │         │─檢查庫存→│         │         │
 │        │         │←──確認──│         │         │
 │        │         │─處理支付→         │         │
 │        │         │←支付確認─│         │         │
 │        │         │─────更新庫存─────→│         │
 │        │         │←────確認────────│         │
 │        │         │─發送確認信─────────────────→│
 │←確認頁面─────────│         │         │         │
```

#### 🔄 序列圖設計要點

**訊息類型**：
- **同步訊息**：`─────>` (等待回應)
- **非同步訊息**：`─────>>` (不等待回應)
- **回應訊息**：`┈┈┈┈>` (回傳結果)
- **自我訊息**：`↰` (物件內部調用)

**最佳實務**：
- 由左至右安排物件順序
- 保持訊息流程清晰
- 標註重要的條件和迴圈
- 避免過度複雜的序列

### 3.4 活動圖設計

#### 🔄 活動圖符號

**基本符號**：
- **開始**：`●` (實心圓)
- **結束**：`◉` (帶圓圈的實心圓)
- **活動**：`矩形`
- **決策**：`◇` (菱形)
- **合併**：`◇` (菱形)
- **分支**：`━━┳━━` (水平線)
- **同步**：`━━┻━━` (水平線)

#### 📝 使用者註冊活動圖

```
        ●
        │
        ▼
   ┌─────────────┐
   │   填寫表單   │
   └─────────────┘
        │
        ▼
      ◇ 資料有效？
     ╱ ╲
    ╱   ╲ 是
   ╱ 否  ╲
  ▼       ▼
顯示錯誤  儲存資料
  │        │
  │        ▼
  │   發送驗證信
  │        │
  │        ▼
  │   顯示成功訊息
  │        │
  └────────┼──────
           ▼
           ◉
```

---

## 🗄️ 第四部分：資料庫設計

### 4.1 資料庫設計流程

#### 📋 設計階段

**1. 概念設計 (Conceptual Design)**
- 識別實體和屬性
- 建立實體關係圖 (ERD)
- 定義業務規則

**2. 邏輯設計 (Logical Design)**
- 正規化處理
- 建立邏輯資料模型
- 定義主鍵和外鍵

**3. 物理設計 (Physical Design)**
- 選擇資料類型
- 建立索引策略
- 效能最佳化

### 4.2 實體關係圖 (ERD)

#### 🔗 ERD基本元素

**符號說明**：
- **實體 (Entity)**：矩形
- **屬性 (Attribute)**：橢圓形
- **關係 (Relationship)**：菱形
- **主鍵**：底線標示
- **外鍵**：虛線標示

#### 🛍️ 電商系統ERD範例

```
┌─────────────┐    1:N    ┌─────────────┐    N:M    ┌─────────────┐
│    User     │━━━━━━━━━━━│    Order    │━━━━━━━━━━━│   Product   │
├─────────────┤          ├─────────────┤          ├─────────────┤
│ PK user_id  │          │ PK order_id │          │ PK product_id│
│    email    │          │ FK user_id  │          │    name     │
│   password  │          │ order_date  │          │ description │
│    name     │          │ total_amount│          │    price    │
│   address   │          │   status    │          │    stock    │
│  created_at │          │  created_at │          │ category_id │
└─────────────┘          └─────────────┘          └─────────────┘
                                │                         │
                                │ 1:N                     │ N:1
                                ▼                         ▼
                         ┌─────────────┐          ┌─────────────┐
                         │ OrderItem   │          │  Category   │
                         ├─────────────┤          ├─────────────┤
                         │ PK item_id  │          │PK category_id│
                         │ FK order_id │          │    name     │
                         │FK product_id│          │ description │
                         │  quantity   │          │  created_at │
                         │ unit_price  │          └─────────────┘
                         │  subtotal   │
                         └─────────────┘
```

### 4.3 正規化設計

#### 📐 正規化階段

**第一正規化 (1NF)**：
- 消除重複群組
- 確保每個欄位都是原子值

**範例轉換**：
```
❌ 未正規化：
訂單ID │ 客戶名稱 │ 商品清單
1      │ 張三     │ 商品A,商品B,商品C
2      │ 李四     │ 商品B,商品D

✅ 第一正規化：
訂單ID │ 客戶名稱 │ 商品名稱
1      │ 張三     │ 商品A
1      │ 張三     │ 商品B  
1      │ 張三     │ 商品C
2      │ 李四     │ 商品B
2      │ 李四     │ 商品D
```

**第二正規化 (2NF)**：
- 滿足1NF
- 消除部分功能相依

**第三正規化 (3NF)**：
- 滿足2NF
- 消除轉移相依

#### ⚖️ 正規化 vs 反正規化

**正規化優點**：
- 減少資料重複
- 提高資料一致性
- 節省儲存空間

**反正規化考量**：
- 提高查詢效能
- 減少複雜聯結
- 適合讀取密集的系統

### 4.4 索引設計

#### 🔍 索引類型

**主要索引類型**：
- **主索引 (Primary Index)**：基於主鍵
- **唯一索引 (Unique Index)**：確保唯一性
- **複合索引 (Composite Index)**：多欄位索引
- **部分索引 (Partial Index)**：條件式索引

**索引設計原則**：
```sql
-- 為經常查詢的欄位建立索引
CREATE INDEX idx_user_email ON users(email);

-- 為複合查詢建立複合索引
CREATE INDEX idx_order_user_date ON orders(user_id, order_date);

-- 為外鍵建立索引
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
```

---

## 🎨 第五部分：使用者介面設計

### 5.1 UI/UX設計原則

#### 🎯 設計原則概覽

**Nielsen的10項可用性原則**：

1. **系統狀態可見性**：讓使用者知道正在發生什麼
2. **系統與現實世界的匹配**：使用使用者熟悉的語言
3. **使用者控制與自由**：提供撤銷和重做功能
4. **一致性與標準**：遵循平台慣例
5. **錯誤預防**：設計防止錯誤發生
6. **識別勝過回憶**：使物件和動作可見
7. **使用彈性與效率**：為專家使用者提供快捷方式
8. **美學與極簡設計**：避免不相關的資訊
9. **幫助使用者識別和解決錯誤**：用清楚的語言表達錯誤
10. **幫助與文件**：提供容易搜尋的幫助資訊

#### 🎨 視覺設計原則

**對比 (Contrast)**：
- 突出重要元素
- 建立視覺階層
- 提高可讀性

**重複 (Repetition)**：
- 建立一致性
- 強化品牌識別
- 創造統一感

**對齊 (Alignment)**：
- 創造視覺連接
- 組織資訊
- 建立專業感

**親近性 (Proximity)**：
- 相關元素群組化
- 減少視覺混亂
- 提高理解效率

### 5.2 資訊架構設計

#### 🗂️ 資訊架構方法

**卡片分類法 (Card Sorting)**：
- 開放式分類：使用者自由分組
- 封閉式分類：預設分類讓使用者歸類
- 混合式分類：結合兩種方法

**網站地圖 (Site Map)**：
```
首頁
├── 商品分類
│   ├── 3C產品
│   ├── 服飾配件
│   └── 生活用品
├── 會員專區
│   ├── 個人資料
│   ├── 訂單記錄
│   └── 收藏清單
├── 購物車
└── 客服中心
    ├── 常見問題
    ├── 聯絡我們
    └── 退換貨政策
```

#### 🧭 導航設計

**導航類型**：
- **主導航**：網站主要功能區域
- **次導航**：分類內的細項功能
- **麵包屑導航**：顯示目前位置
- **相關連結**：推薦相關內容

**導航最佳實務**：
- 保持簡潔明確
- 使用常見的標籤術語
- 提供視覺回饋
- 確保在所有頁面一致

### 5.3 介面元素設計

#### 🔘 表單設計

**表單設計原則**：
- **邏輯分組**：相關欄位群組化
- **明確標籤**：使用清楚的欄位標籤
- **即時驗證**：提供即時回饋
- **錯誤處理**：清楚的錯誤訊息

**表單範例**：
```
┌─────────────────────────────────┐
│          使用者註冊              │
├─────────────────────────────────┤
│ 基本資料                        │
│ ┌─────────────────────────────┐ │
│ │ 電子郵件 *                   │ │
│ │ ┌─────────────────────────┐ │ │
│ │ │ your.email@example.com  │ │ │
│ │ └─────────────────────────┘ │ │
│ └─────────────────────────────┘ │
│                                 │
│ ┌─────────────────────────────┐ │
│ │ 密碼 *                      │ │
│ │ ┌─────────────────────────┐ │ │
│ │ │ ••••••••••••••••••••••  │ │ │
│ │ └─────────────────────────┘ │ │
│ │ 至少8個字元，包含大小寫字母   │ │
│ └─────────────────────────────┘ │
│                                 │
│ ┌─────────────────────────────┐ │
│ │ ☑ 我同意服務條款             │ │
│ └─────────────────────────────┘ │
│                                 │
│ ┌─────────────────────────────┐ │
│ │        [ 註    冊 ]         │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

#### 📱 響應式設計

**設計原則**：
- **流動格線**：使用百分比而非固定像素
- **彈性圖片**：圖片大小隨容器調整
- **媒體查詢**：針對不同螢幕尺寸調整樣式

**斷點設計**：
```css
/* 手機 */
@media (max-width: 767px) {
    .container { width: 100%; }
}

/* 平板 */
@media (min-width: 768px) and (max-width: 1023px) {
    .container { width: 750px; }
}

/* 桌機 */
@media (min-width: 1024px) {
    .container { width: 970px; }
}
```

### 5.4 原型設計

#### 🎨 原型類型

**低保真原型**：
- 快速概念驗證
- 線框圖設計
- 紙本原型

**中保真原型**：
- 較詳細的介面設計
- 基本互動功能
- 數位工具製作

**高保真原型**：
- 接近最終產品
- 完整互動體驗
- 可用性測試

#### 🛠️ 原型設計工具

**設計工具比較**：

| 工具 | 類型 | 學習曲線 | 協作功能 | 互動性 |
|------|------|----------|----------|--------|
| **Figma** | 線上 | 中等 | 優秀 | 高 |
| **Sketch** | 桌面 | 中等 | 良好 | 中 |
| **Adobe XD** | 桌面/線上 | 中等 | 良好 | 高 |
| **Balsamiq** | 線上 | 容易 | 普通 | 低 |
| **InVision** | 線上 | 容易 | 優秀 | 中 |

---

## 📄 第六部分：設計文件化

### 6.1 系統設計文件結構

#### 📋 設計文件大綱

**標準設計文件結構**：

```
1. 文件資訊
   1.1 文件版本
   1.2 作者與審核者
   1.3 變更記錄

2. 系統概述
   2.1 系統目標
   2.2 設計範圍
   2.3 設計約束

3. 架構設計
   3.1 系統架構
   3.2 技術架構
   3.3 部署架構

4. 詳細設計
   4.1 模組設計
   4.2 介面設計
   4.3 資料設計

5. 非功能設計
   5.1 效能設計
   5.2 安全設計
   5.3 可用性設計

6. 附錄
   6.1 詞彙表
   6.2 參考資料
   6.3 設計決策記錄
```

### 6.2 設計決策記錄

#### 📝 ADR撰寫指南

**ADR模板格式**：
```markdown
# ADR-[編號]: [決策標題]

## 狀態
[提議中/已接受/已廢棄/已取代]

## 背景
[描述促成決策的情境和問題]

## 考慮的方案
[列出評估過的選項]

## 決策
[選擇的方案和理由]

## 後果
[決策的正面和負面影響]
```

**範例ADR**：
```markdown
# ADR-003: 資料庫技術選擇

## 狀態
已接受

## 背景
系統需要存儲使用者資料、商品資訊和訂單記錄。
考慮到擴展性和查詢效能需求。

## 考慮的方案
1. MySQL - 關聯式資料庫
2. MongoDB - 文件資料庫  
3. PostgreSQL - 物件關聯式資料庫

## 決策
選擇PostgreSQL作為主要資料庫

理由：
- 支援複雜查詢和事務
- JSON支援提供NoSQL彈性
- 豐富的擴充功能
- 團隊有使用經驗

## 後果
正面影響：
- 資料一致性保證
- 豐富的查詢功能
- 社群支援完善

負面影響：
- 相較NoSQL效能較低
- 需要仔細的schema設計
```

### 6.3 設計審查

#### 🔍 設計審查流程

**審查階段**：

**1. 自我審查**：
- 檢查設計完整性
- 驗證需求滿足度
- 確認設計一致性

**2. 同儕審查**：
- 技術可行性評估
- 設計最佳實務檢查
- 潛在問題識別

**3. 正式審查**：
- 利害關係人參與
- 設計決策確認
- 風險評估

#### ✅ 設計審查檢查清單

**架構審查**：
- [ ] 架構模式選擇合適
- [ ] 系統分解邏輯清楚
- [ ] 技術選擇有依據
- [ ] 非功能需求考慮完整
- [ ] 整合介面定義清楚

**詳細設計審查**：
- [ ] 類別設計符合SOLID原則
- [ ] 介面定義明確
- [ ] 錯誤處理機制完整
- [ ] 效能考量適當
- [ ] 安全性機制足夠

**資料設計審查**：
- [ ] 資料模型正規化適當
- [ ] 主鍵外鍵定義正確
- [ ] 索引策略合理
- [ ] 資料完整性約束完整
- [ ] 備份恢復策略明確

---

## 🏃‍♂️ 實務練習

### 練習1：線上書店系統架構設計

**專案背景**：
設計一個中型線上書店系統，支援以下功能：
- 使用者註冊登入
- 書籍瀏覽搜尋
- 購物車管理
- 訂單處理
- 庫存管理
- 評論系統

**系統需求**：
- 支援1萬名並發使用者
- 99.9%可用性要求
- 支援手機和桌面瀏覽
- 與第三方支付系統整合

**任務1：架構設計**
1. **選擇架構模式**
   - 分析不同架構模式的適用性
   - 說明選擇理由
   - 繪製高層架構圖

2. **技術架構設計**
   - 前端技術棧選擇
   - 後端技術棧選擇
   - 資料庫技術選擇
   - 快取策略設計

3. **部署架構設計**
   - 伺服器配置規劃
   - 負載平衡策略
   - 監控與日誌設計

**提交成果**：
- 架構設計圖
- 技術選擇說明
- ADR文件（至少3個重要決策）

### 練習2：UML設計圖繪製

**基於練習1的線上書店系統，繪製以下UML圖表**：

**任務2.1：類別圖設計**
設計核心業務類別：
- User（使用者）
- Book（書籍）
- ShoppingCart（購物車）
- Order（訂單）
- Review（評論）

要求：
- 包含屬性和方法
- 標示關聯關係
- 註明多重性
- 遵循設計原則

**任務2.2：序列圖設計**
繪製以下使用案例的序列圖：
- 使用者登入流程
- 加入購物車流程
- 訂單結帳流程

要求：
- 包含所有參與物件
- 標示訊息交換
- 註明條件和迴圈
- 考慮異常情況

**任務2.3：活動圖設計**
繪製訂單處理的完整活動圖，包含：
- 訂單建立
- 庫存檢查
- 支付處理
- 出貨流程

**提交成果**：
- 完整的UML圖表（使用工具繪製）
- 設計說明文件

### 練習3：資料庫設計

**為線上書店系統設計完整的資料庫**：

**任務3.1：ERD設計**
1. 識別主要實體：
   - 使用者、書籍、分類、作者
   - 訂單、訂單項目、購物車
   - 評論、庫存、支付記錄

2. 定義實體關係：
   - 標示關係類型（1:1, 1:N, N:M）
   - 定義主鍵和外鍵
   - 標註約束條件

**任務3.2：資料表設計**
```sql
-- 範例：使用者表
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    address TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**任務3.3：索引策略**
設計查詢最佳化的索引：
- 識別常用查詢模式
- 建立適當的索引
- 考慮複合索引

**提交成果**：
- ERD圖表
- 完整的DDL語句
- 索引設計說明

### 練習4：UI/UX設計

**設計線上書店的使用者介面**：

**任務4.1：資訊架構**
1. 網站地圖設計
2. 導航結構規劃
3. 使用者流程設計

**任務4.2：線框圖設計**
設計以下頁面的線框圖：
- 首頁
- 書籍列表頁
- 書籍詳情頁
- 購物車頁面
- 結帳頁面

**任務4.3：高保真原型**
選擇一個核心流程（如購買流程）製作可互動的原型

**設計要求**：
- 響應式設計
- 符合可用性原則
- 一致的視覺風格
- 考慮無障礙設計

**提交成果**：
- 網站地圖
- 線框圖集合
- 高保真原型連結
- 設計決策說明

---

## 📝 知識檢核測驗

### 選擇題 (每題5分，共50分)

**1. SOLID原則中的"S"代表什麼？**
A) Security Principle
B) Single Responsibility Principle  
C) System Principle
D) Simple Principle

**2. 下列哪個不是常見的架構模式？**
A) 分層架構
B) 微服務架構
C) 事件驅動架構
D) 瀑布架構

**3. UML類別圖中，組合關係的符號是？**
A) ◇────>
B) ◆────>
C) ────△
D) ┈┈┈>

**4. 資料庫第三正規化的目的是？**
A) 消除重複群組
B) 消除部分功能相依
C) 消除轉移相依
D) 提高查詢效能

**5. Nielsen可用性原則中，"系統狀態可見性"的意思是？**
A) 系統界面要美觀
B) 讓使用者知道系統正在做什麼
C) 系統要快速回應
D) 系統要容易學習

**6. 序列圖中的生命線表示什麼？**
A) 物件間的關係
B) 物件存在的時間
C) 方法執行的順序
D) 資料的流向

**7. 下列哪個不是設計模式的分類？**
A) 創建模式
B) 結構模式
C) 行為模式
D) 資料模式

**8. 響應式設計的核心概念不包括？**
A) 流動格線
B) 彈性圖片
C) 媒體查詢
D) 固定佈局

**9. ADR（架構決策記錄）的主要目的是？**
A) 記錄程式碼變更
B) 記錄設計決策過程
C) 記錄測試結果
D) 記錄專案進度

**10. 高內聚低耦合原則的好處不包括？**
A) 提高可維護性
B) 提高可重用性
C) 提高系統效能
D) 降低系統複雜度

### 簡答題 (每題25分，共50分)

**1. 請說明微服務架構與單體架構的主要差異，並分析在什麼情況下會選擇微服務架構？包括其優缺點分析。(300字)**

**2. 解釋資料庫正規化的目的和過程，並說明在什麼情況下會考慮反正規化？請舉例說明。(300字)**

---

## 📚 延伸學習資源

### 必讀書籍
1. **《Clean Architecture》** - Robert C. Martin
2. **《設計模式》** - Gang of Four
3. **《資料庫系統概念》** - Abraham Silberschatz
4. **《About Face：介面設計精髓》** - Alan Cooper
5. **《系統分析與設計》** - Dennis, Wixom & Roth

### 線上課程
1. **軟體架構師認證** - SEI Software Architecture
2. **AWS解決方案架構師** - 雲端架構設計
3. **Google UX設計專業證書** - UI/UX設計
4. **資料庫設計課程** - Stanford Database Course

### 設計工具
1. **架構設計**：
   - Draw.io - 免費圖表工具
   - Lucidchart - 專業圖表平台
   - Archimate - 企業架構建模

2. **UML工具**：
   - PlantUML - 程式碼驅動UML
   - StarUML - 專業UML工具
   - Visual Paradigm - 企業級建模

3. **資料庫設計**：
   - MySQL Workbench - MySQL設計工具
   - pgAdmin - PostgreSQL管理工具
   - ERDPlus - 線上ERD工具

4. **UI/UX設計**：
   - Figma - 協作設計平台
   - Adobe XD - 使用者體驗設計
   - Sketch - Mac專用設計工具

### 設計模式資源
1. **線上模式庫**：
   - Refactoring.Guru - 設計模式教學
   - SourceMaking - 模式和反模式
   - Gang of Four Patterns

2. **架構模式**：
   - Microsoft Application Architecture Guide
   - AWS Architecture Patterns
   - Google Cloud Architecture Framework

---

## ✅ 學習檢核表

- [ ] 理解系統設計的基本原則和目標
- [ ] 掌握SOLID原則和其他設計原則
- [ ] 了解常見的軟體架構模式
- [ ] 能夠進行架構決策和權衡分析
- [ ] 熟悉UML各種圖表的繪製
- [ ] 掌握類別圖和序列圖設計技巧
- [ ] 了解資料庫設計和正規化過程
- [ ] 能夠設計ERD和資料表結構
- [ ] 理解UI/UX設計原則
- [ ] 能夠設計使用者介面原型
- [ ] 知道如何撰寫設計文件
- [ ] 了解設計審查的重要性和方法
- [ ] 完成所有實務練習
- [ ] 通過知識檢核測驗 (70分以上)

---

## 🔮 下週預告

**第五模組：程式開發與實作 (第6週)**

我們將學習：
- 編碼標準與最佳實務
- 版本控制系統的有效使用
- 程式碼審查流程與技巧
- 重構方法與工具
- 開發環境的建置與管理

**實務重點**：
- 建立團隊編碼規範
- 實踐Git工作流程
- 進行程式碼品質改善
- 設置自動化開發環境

---

## 🌟 學習反思

請花15分鐘思考以下問題：

1. **設計思維**：系統設計與程式設計的主要差異是什麼？
2. **架構決策**：如何平衡不同架構方案的優缺點？
3. **工具應用**：哪些設計工具對您最有幫助？為什麼？
4. **實務挑戰**：在實際設計中最容易遇到的困難是什麼？
5. **持續改善**：如何持續提升系統設計和架構能力？

---

**🎉 恭喜完成第四模組！**  
*您現在已經掌握了系統設計的核心技能，能夠從需求出發設計完整的系統架構。準備好進入程式開發實作的技術領域了！*